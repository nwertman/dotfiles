" Add a red column at 80 characters
"hi ColorColumn guibg=#2d2d2d
"set colorcolumn=80

"set foldmethod=indent
"
"
function! RunPry (path)
  let target = g:tmux_sessionname . ":Pry.0"
  let command = substitute("\nload \"" . a:path . "\"\n", "'", "'\\\\''", 'g')
  call system("tmux set-buffer '" . command . "'" )
  call system("tmux paste-buffer -t " . target)
  call system("tmux select-window -t " . g:tmux_sessionname . ":Pry")
endfunction

function! RunCommand ()
  let target = g:tmux_sessionname . ":2.0"
  let command = substitute("\n!!\n", "'", "'\\\\''", 'g')
  call system("tmux set-buffer '" . command . "'" )
  call system("tmux paste-buffer -t " . target)
  call system("tmux select-window -t " . g:tmux_sessionname . ":2")
endfunction

set t_Co=256
set bg=dark
color jellybeans
set listchars=tab:▸\ ,eol:¬

" Use fancy NERDTree drawing"
let g:NERDTreeWinPos = "left"
let NERDTreeDirArrows = 1
let NERDTreeMouseMode = 3

map <S-h> gT
map <S-l> gt
map tn :tabnew<CR>
map td :tabclose<CR>

" Ignore syntax highlighting on txt files
au BufRead,BufNewFile *.txt setfiletype ignored

" Setup our primary tmux session
let g:tmux_sessionname = system("tmux list-sessions | grep '(attached)' | sed  's/\:.*//' | tr -d '\n'")
let g:VimuxHeight = 30

map <Leader>ri :call VimuxInspectRunner()<CR>
map <Leader>rq :call VimuxCloseRunner()<CR>
map <Leader>rs :call VimuxInterruptRunner()<CR>
map <Leader>rf :w<bar>:RunRubyFocusedTest<CR>
map <Leader>rb :w<bar>:RunAllRubyTest<CR>
map <Leader>rl :w<bar>:call VimuxRunLastCommand()<CR>
map <Leader>rp :w<bar>:call RunPry(expand('%'))<CR>
map <Leader>rc :w<bar>:call RunCommand()<CR>
" map <S-k> :call VimuxScrollUpInspect()<CR>
" map <S-j> :call VimuxScrollDownInspect()<CR>

"nmap <silent> <C-h> :wincmd h<CR>
"nmap <silent> <C-j> :wincmd j<CR>
"nmap <silent> <C-k> :wincmd k<CR>
"nmap <silent> <C-l> :wincmd l<CR>

" Toggle paste mode using <F2>
noremap <F2> :set invpaste paste?<CR>
set pastetoggle=<F2>
set showmode

" Work related abbreviations
abbr a_cdc c = CoreOSData.client()

" Only remove trailing white spaces when compiled with support for
" autocommands
if has("autocmd")
  autocmd BufWritePre *.rb :call <SID>StripTrailingWhitespaces()
endif

nnoremap <silent> <F5> :call <SID>StripTrailingWhitespaces()<CR>
function! <SID>StripTrailingWhitespaces()
  " Preparation: save last search, and cursor position
  let _s=@/
  let l = line(".")
  let c = col(".")
  
  " Do the strip
  %s/\s\_$//e

  " Restore our settings
  let @/=_s
  call cursor(l, c)
endfunction
